LARAVEL-
para iniciar projeto:
vou no terminal cmd, digito:

composer create-project --prefer-dist laravel/laravel blog

laravel/laravel -> DISTRIBUIDOR/PACOTE; o distribuidor pode ter n pacotes, 'blog' é o nome da aplicação que iremos usar laravel.
dentro do diretorio que foi criado, no caso, 'blog', temos um diretorio chamado 'public'. este diretorio é o qual será servido para servidor http.

pra ver se ta funcionando, vá até o public no terminal, e digite:
php -S localhost:PORTA -> a porta pode ser qq porta q esteja livre, ex: php -S localhost:8000

http://localhost:8000 -> este será o endereço no qual a aplicação será servida. se chegar na pagina do laravel, a aplicação foi iniciada com sucesso. pra interromper, dá CTRL C.


///////////////////

Rotas, Controllers e Views:

Artisan Controle -
Artesão do laravel. smp qd iniciamos novo projeto, o artisan é incluido no projeto. vai no diretorio q foi construido ao iniciar projeto, no caso, 'blog', e verás lá: "artisan". para acessá-lo, no terminal, digite, no diretorio onde iniciou o projeto laravel: 
php artisan list.
agora, para iniciar a aplicação basta usar:

php artisan serve

/\ bem melhor que usar php -S ....

pra definir a porta:
php artisan serve --port=9000

// mas se tentar acessar a aplicaçao no browser com 127.0.0.1:9000 -> verá q tará service unaivable
// basta dar:
php artisan up

// e agora servir a aplicaçao novamente:
php artisan serve --port=9000

//////////////

Rotas ( routes ) do Laravel - Introdução
O que são rotas?
Rotas representam caminhos existentes dentro da aplicação. ao acessar um recurso da aplicaçao atraves de uma url, estamos na pratica acessando uma rota.
3 rotas distintas:
www.minhaaplicacao.com.br // pagina inicial da aplicaçao 
www.minhaaplicacao.com.br/sobrenos // pagina falando um pouco do projeto
www.minhaaplicacao.com.br/contato // pagina de contato

/\ // portanto, 3 paginas que deverao ser construidas de modo distinto

Organizaçao das rotas no Laravel: 4 arquivos de rotas distintas:

API
Channels
Console
Web 
(esses arquivos estão dentro da pasta routes)

criei um novo projeto aqui chamado 'conhecimentos'. 
adicionemos o projeto (diretorio Conhecimentos) no VSCode.

vemos que temos a raiz do diretorio 'Routes' em 'Conhecimentos'. vemos o 'api.php, channels, console e web'.

web.php serve pra registrar as rotas no velho estilo web. ou seja, processando paginas no lado back-end e servindo essas paginas em respostas e requisiçoes, permitindo inclusive a utilizaçao de recursos como cookies e sessões. 

api.php serve pra registrar rotas de uma api, não suportando, portanto, os recursos de cookies e sessões, uma vez que APIs possuem o proposito de responder dados às requisitas feitas, isto é, recurso ideal, onde front-end é separado de back-end conversando atraves de uma aplicaçao API.

channels.php serve para definição de rotas de comunicação broadcasting, este tipo de recurso serve como comunicação real, através do uso de  certas tecnologias. diferente do metodo tradicional de requisiçao e resposta, onde um cliente, ou seja, uma aplicaçao front end faz uma requisição para o servidor, e o servidor fornece uma resposta, este tipo de comunicação segue o canal oposto, ou seja, permite que a aplicação servidora notifique os clientes de atualizações ao lado do back-end, possibilitando ao front-end renderizar automaticamente essas mudanças que foram notificadas pelo servidor, dando a ideia de tempo real.

console.php serve para criação de comandos personalizados que serão executados a partir do Artisan.

//////////////

Super Gestão - Implementando as rotas: principal, sobre-nos e contato
no modelo tradicional de desenvolvimento, as views são renderizadas no lado do servidor. pra implementar nossas rotas, usemos o arquivo 'web.php' dentro do diretorio 'routes'. ao chegar na pasta, verá que já terá uma rota, q é a rota principal, em: Route::get('/',, function () { ... }); , '/' é a rota principal, qualquer acesso feito diretamente para nossa aplicação qd ela é servida, é direcionado para essa rota ( / ) desde que não indiquemos na URL nenhum caminho específico, nenhuma rota especifica.
no web.php , verá tem q uma view, q é a view padrão da instação de novos projetos laravel, isto é, vem com o projeto para fins de testes:
return view('welcome');

colocamos return 'Olá'; e irá mostrar 'olá'

agora, coloquemos novas rotas:
Route::get('/', function () {
    return 'Olá';
});

Route::get('/sobre-nos', function () {
    return 'Sobre-nos';
});


Route::get('/contato', function () {
    return 'Contato';
});

ao acessar http://127.0.0.1:8000/sobre-nos e http://127.0.0.1:8000/contato , que são as novas rotas, irá mostrar o texto q colocamos de retorno.

O objeto 'Route' é quem vai cuidar de toda essa parte de roteamento da aplicação e definimos as rotas e os métodos verbos HHTP através do método 'get'.
// VERBOS HTTP:
get
post
put
patch
delete
options

são os principais verbos HTTP que podem ser utilizados para controlar nossas requisiçoes que são feitas para nosso servidor, para nossa aplicação

então, em, por ex:

Route::get('/contato', function () {
    return 'Contato';
});

------>/\ estamos definindo o verbo HTTP 'get', passando pro objeto 'Route', através do método 'get' uma URI '/contato', ou seja, nossa rota, e o segundo parâmetro, uma função de callback, ou seja, uma ação que deve ser tomado quando a rota (/contato) for acessada pelo respectivo método (get).
Route::get($uri, $callback)

/////////////////
Controladores:

Os controllers servem para agrupar a lógica que deve ser feita em função da rota acessada por um determinado cliente. Ao fazermos uma requisição para o servidor, isto é, ao acessarmos uma rota da aplicação, essa rota por sua vez estará associado a um Controller e uma action, ou seja, a um controlador e a uma ação dentro desse controlador, contendo a lógica do que deve ser feito em função da rota q foi acessada.
essa separação entre rotas e controladores permite separar melhor o código, definindo responsabilidades claras para cada parte do framework.
embora as rotas implimentem funções de callback, e essas funçoes de callback possam ser usadas para definir toda logica com base na rota a ser acessada, o ideal é direcionarmos as requisiçoes para os controladores, para ai sim iniciarmos as tratativas com base nas requisições, mantendo portanto a separação clara entre rotas e controladores.
separaçao importante pq em rotas temos implementações mais focadas para questoes tecnicas das aplicações em si, nos verbos HTTP utilizados, bem como nos middlewares que podem ser usadas nas requisiçoes e respostas
já no Controller é mais necessaria para atender os requisitos do negocio, é bem nos action que vamos definir o que a funçao deve fazer pelo que foi requisitado através de uma Rota.

/////////////

Implementando os controladores: principal, sobre-nos e contato:
Os controladores, na prática, são classes, para nomeá-los, usamos Camel Case

no terminal, dentro da raiz do projeto, executemos:
php artisan make:controller PrincipalController // PrincipalController é o nome do Controlador,, fazemos este comando para criar uma nova classe de controlador

Os controllers ficam dentro da pasta do projeto, app > http > controllers > nomedocontrolador.php , este arquivo foi criado dentro da estrutura da framework com uma estrutura padrão.

temos o namespace desta classe, inclusão da classe Request no contexto e a definição da classe com o nome extendendo a classe 'Controller'.
basta criarmos o método dentro da classe.

class PrincipalController extends Controller
{
    public function principal(){
        echo 'Olá'; // colocamos aqui um echo no que estava sendo processado na própria rota. o nome do método pode ser qualquer, coloquei apenas "principal". no contexto de um controlador, os métodos são conhecidos como 'actions', então esse 'principal' é um action
    }
}

// actions serão os métodos que estarão dentro dos controladores que serão associados às rotas, pq a rota não chamará apenas o controlador, mas sim um método desse controlador. a conexão é da rota para com o método. 
// associemos a raiz da nossa aplicação ( / ) com a action principal da classe PrincipalController

// agora, vamos em web.php, e colocamos uma Rota, e alteramos, em vez de passar função (caso coloquemos função ele entenderá como função Callback), agora vamos colocar o Controller, e ele entenderá que estamos indicando um controlador e uma ação que deve ser executada quando a rota '/' for chamada.
Route::get('/', [\App\Http\Controllers\PrincipalController::class, 'principal']);

// agora, faremos para o resto:
php artisan make:controller SobreNosController
php artisan make:controller ContatoController

agora, vms nesses arquivos criados, e vamos abrir as functions
class SobreNosController extends Controller
{
    public function sobreNos() {
        echo 'Sobre-nós';
    }
}
pro contato msm coisa.

agora, dnv no web.php, para as rotas:
Route::get('/sobre-nos', [\App\Http\Controllers\SobreNosController::class, 'sobreNos']);

Route::get('/contato', [\App\Http\Controllers\ContatoController::class, 'contato']);

agora estamos respeitando as responsabilidades das partes do nosso framework, de um lado as rotas que visam organizar as rotas da aplicação em si, e do outro lado os Controladores, q são as camadas do framework, que permitem organizar todas as lógicas de fato

///////////////

Views -
As views são as visões que reproduzimos no lado do servidor e retornamos em sequencia para o cliente que fez a requisição => modelo tradicional das requisições web, que as views sao processadas no lado do servidor e enviadas de volta para quem fez a requisição.
hoje, tem uma tecnica mais moderna, onde existe separaçao do back-end e do front-end em aplicações distintas, conectadas via API.

Basicamente, as views conterão todo o HTML que serão processados no lado do back-end.

As views ficarão em: resources/views. em 'views', podemos criar outros diretórios. criamos um diretorio chamado 'app' e outro 'site'.
dentro de 'site', criamos um arquivo chamado: principal.blade.php
'.blade.php' no final do nome do arquivo é um padrão do laravel, pq as views serão processados por um recurso chamado 'blade' do framework laravel. todas as views precisam finalizar com '.blade.php'.
em 'principal.blade.php' é onde de fato iremos incluir toda codificação html. criamos o sobre-nos.blade.php e o contato.blade.php

colocamos <h2>Sobre nos(view)</h2> em cada arquivo

agora, precisamos ajustar as actions, que estão sendo associadas para as rotas, para que essas actions/métodos, trabalhem com as views.
la em 'controllers', nos arquivos controladores, nas funções/metodos/actions, em vez de dar echo na info, vamos substituir a instruçao pela renderização da view.
em vez de return echo 'Olá', coloquemos:
return view('site.principal'); // ele ja subentende que ta dentro de views, apenas colocamos onde a view tá, dentro do diretorio 'site' que criamos e colocando '.principal' pra saber o arquivo tb. pode-se omitir blade.php, pois o framework ja entende q é uma view

//////////////

Enviando parâmetros -
Como enviar parametros atraves das rotas;
dentro do web.php, criemos uma nova rota:

Route::get('/contato{nome}', function () {
    echo 'Estamos Aqui';
});

/\ esta rota está esperando um parametro (nome), este parametro que está sendo esperado precisa ser encaminhado pra nossa função de callback:
Route::get('/contato{nome}', function ($nome) {
    echo 'Estamos Aqui';
});

/\ embora defini como $nome, com o mesmo nome do parametro, poderia ter nome xyz, isto é, $xyz, pq, na verdade, o que importa é a sequencia dos parametros. vamos tipar a variavel sendo string, um novo recurso do PHP:
Route::get('/contato/{nome}', function (string $cyz) {
    echo 'Estamos Aqui'.$xyz; // concatenamos
});
Ao acessar: http://127.0.0.1:8000/contato/Luiz
Irá mostrar -> estamos aqui: Luiz

// Outro jeito:
Route::get('/contato/{nome}/{categoria}/{telefone}', function (string $xyz, string $z, string $y) {
    echo 'Estamos Aqui: '.$xyz. ' Categoria: '.$z. ' Telefone: '.$y; // concatenamos
});
Ao acessar: hhttp://127.0.0.1:8000/contato/Luiz/SAI/21%20979007792
Irá mostrar: Estamos Aqui: Luiz Categoria: SAI Telefone: 21 979007792 // %20 é o espaço

// Lembrando que, o que importa é a sequencia dos parametros


//////////////
Parametros opcionais e valores padrões -
Para indicar que é opcional, basta indicar o '?' que o Laravel entenderá q é opcional:
Route::get('/contato/{nome}/{categoria}/{telefone?}', function (string $nome, string $categoria, string $telefone = 'Telefone não Informado') {
    echo 'Estamos Aqui: '.$nome. ' Categoria: '.$categoria. ' Telefone: '.$telefone; // concatenamos
});

// Se nenhuma informaçao for enviada, receberá como valor padrão 'Telefone não Informado'. O Laravel tem limitaçao com parametros opcionais,por ex, nao posso definir que o nome é opcional, pois o Laravel irá se perder na hora de sequenciar os parametros. então, os parametros opcionais devem ser passados da direita para esquerda, de modo que o Laravel saiba sequenciar os parametros que está recebendo.
exs:
Route::get('/contato/{nome?}/{categoria}/{telefone?}', function (string $nome = Nenhum, string $categoria, string $telefone = 'Telefone não Informado') {
    echo 'Estamos Aqui: '.$nome. ' Categoria: '.$categoria. ' Telefone: '.$telefone; // concatenamos
});
/\ daria erro, pois é da direita p esquerda. telefone teria q ser opcional, categoria tambem, para ai sim o 'nome' ser opcional.

/////////////

Tratando parametros de rotas com expressoes regulares-
As rotas só serão processadas se os parametros enviados forem compativeis com as condiçoes que estabelecermos previamente para cada um deles.
Route::get('/contato/{nome}/{categoria_id}', function (string $nome, string $categoria_id) {
    echo "Estamos Aqui: $nome - $categoria_id" // concatenamos
});

/\ na categoria, no formulario de contato, seria um select com possibilidades de categorias.

Route::get('/contato/{nome}/{categoria_id}', function (
    string $nome = 'Desconhecido',
    int $categoria_id = 1 // 1 - Informação
    ) {
        echo "Estamos Aqui: $nome - $categoria_id"; // concatenamos
    }
);

/\ ao digitar: http://127.0.0.1:8000/contato/Ana/2 , irá numa boa, mas se eu digitar '/Ana/Duvidas', vai dar erro, pois eu tipei a variável como int. para tratar este tipo de situaçao, usemos expressões regulares, usando tratamento especifico para cada parametro da rota, isto é, em vez de erro do php, usamos expressoes regulares para indicar quais condiçoes para dizer qual parametro esta apto para receber tal categoria. em categoria podemos usar expressao regular pra dizer q ele precisa ser combinaçao de caracteres q tenha apenas numeros e q vá de 1 a 9. usamos: ->where('', '');

Route::get('/contato/{nome}/{categoria_id}', function (
    string $nome = 'Desconhecido',
    int $categoria_id = 1 // 1 - Informação
    ) {
        echo "Estamos Aqui: $nome - $categoria_id"; // concatenamos
    }
)->where('categoria_id', '[0-9]+'); // o primeiro parametro é o nome do parametro que estamos recebendo na rota, no caso, categoria_id, o 2 parametro é a expressão regular para aceitarmos ou não o parametro de categoria_id. como dito, precisa ser um parametro numerico, precisa estar entre 0 e 9, e pelo menos um caractere.

// expressao regular pro nome agora, faça nova chamada com o parametro where:
Route::get('/contato/{nome}/{categoria_id}', function (
    string $nome = 'Desconhecido',
    int $categoria_id = 1 // 1 - Informação
    ) {
        echo "Estamos Aqui: $nome - $categoria_id"; // concatenamos
    }
)->where('categoria_id', '[0-9]+')->where('nome', 'A-Za-z'+); -> A-Z e a-z e pelo menos 1 caractere 

///////////////

Criando o menu de navegação -
Implementar menu de navegação entre as views pra permitir navegar entre as rotas de aplicação.

Dentro da view principal.blade.php:
<h2>Principal (view)</h2>

<ul>
    <li>
        <a href="/"> Principal</a> // aqui, a rota que leva para a pagina 'principal' é '/', conforme se vê em web.php
    </li>
    <li>
        <a href="/sobre-nos">Sobre Nós</a>
    </li>
    <li>
        <a href="/contato">Contato</a>
    </li>
</ul>

// /\ coloquemos este codigo em contato e em sobre-nos

// com o php artisan, temos um comando chamado: route:list, que permite listar as rotas criadas dentro do projeto. use: php artisan route:list. o visual code permite usar 2 terminais ao mesmo tempo.

////////////////

Implementando as rotas login, clientes, fornecedores e produtos -
Vamos em 'web.php', e adicionemos as routes::get, novas rotas.

Route::get('/login', function() { return 'Login'; });

Route::get('/clientes', function() { return 'Clientes'; });

Route::get('/fornecedores', function() { return 'Fornecedores'; });

Route::get('/produtos', function() { return 'Produtos'; });

//////////////

Agrupando Rotas -
Agrupar rotas usando um prefixo.
Vamos pegar as 3 rotas novas que criamos, clientes, fornecedores e produtos, e agrupar em uma rota chamada 'app'.
para definir o prefixo, basta usar o objeto 'Route::' chamando o método prefix(), esse método espera por parametro o prefixo a ser utilizado, e chamamos em sequencia o metodo 'group' que espera uma função callback com todas as rotas q farão parte desse grupamento q serão acessadas a partir do prefixo dado.
Em web.php:

Route::prefix('/app')->group(function() {
    Route::get('/clientes', function() { return 'Clientes'; });
    Route::get('/fornecedores', function() { return 'Fornecedores'; });
    Route::get('/produtos', function() { return 'Produtos'; });
});

////////////////

Nomeando Rotas -
Como nomear rotas da aplicação? Permitindo chamar as rotas pelo nome, e não pelo caminho absoluto. Basta que, em web.php, após a chamada do metodo 'get', chamemos outro método chamado 'name', passando como parametro o nome que deseja. pode ser o nome que quiser.

------> os names podem ser usados com os métodos 'helpers' do framework Laravel. significa que os names podem ser utilizados apenas dentro da propria logica da nossa aplicação.

Route::get('/', [\App\Http\Controllers\PrincipalController::class, 'principal'])->name('site.index');
Route::get('/sobre-nos', [\App\Http\Controllers\SobreNosController::class, 'sobreNos'])->name('site.sobrenos');

Route::get('/contato', [\App\Http\Controllers\ContatoController::class, 'contato'])->name('site.contato');

Route::get('/login', function() { return 'Login'; })->name('site.login');

Route::prefix('/app')->group(function() {
    Route::get('/clientes', function() { return 'Clientes'; })->name('app.clientes');
    Route::get('/fornecedores', function() { return 'Fornecedores'; })->name('app.fornecedores');
    Route::get('/produtos', function() { return 'Produtos'; })->name('app.produtos');
});

/\ // isso não significa q se eu chamar: localhost:8000/app.clientes vai funcionar. vai dar erro. apenas significa que a rota localhost:8000/rotas/app/clientes vai ter um nome chamado app.clientes, um apelido pra chamada dessa rota. vamos numa view qualquer, pd ser principal.blade.php, lá temos nossa view com nossas referencias absolutas (/, /sobrenos e /contato). como temos nomeaçao das rotas, agora podemos usar esses apelidos. apenas basta usarmos: {{ route('nomedoalias') }} passa como apelido pra nossa rota. 


no principal.blade.php:
<h2>Principal (view)</h2>

<ul>
    <li>
        <a href="{{ route('site.index') }}"> Principal</a>
    </li>
    <li>
        <a href="{{ route('site.sobrenos') }}">Sobre Nós</a>
    </li>
    <li>
        <a href="{{ route('site.contato') }}">Contato</a>
    </li>
</ul>

// passando como rota alias/nome, o laravel retorna o caminho. a vantagem é não ter dependencia absoluta com a rota, caso mude o caminho em web.php. 

/////////////////

Redirecionamento de rotas -
Permite redirecionar o fluxo de navegação do usuário pela aplicação web.
Cair em uma rota e ser redirecionado para outra rota.

vamos passar um método 'redirect':

Dentro do web.php:
Route::get('/rota1', function() {
    echo 'Rota 1';
})->name('site.rota1');

Route::get('/rota2', function() {
    echo 'Rota 2';
})->name('site.rota2');

Route::redirect('/rota2', '/rota1'); // ao acessarmos '/rota2', seremos redirecionados para '/rota1'.

// -------> passando agora no callback da rota2:

Route::get('/rota1', function() {
    echo 'Rota 1';
})->name('site.rota1');

Route::get('/rota2', function() {
    return redirect()->route('site.rota1'); // redirecionamento no contexto da funçao de callback de uma rota agora.
})->name('site.rota2');


///////////////

Rota de contingência (fallback) -
É uma rota que vai ser disponibilizada para o usuário caso a rota acessada por ele não seja localizada dentro do sistema de rotas da nossa aplicação. Ou seja, se tentar acessar uma rota inexistente, a rota direcionada pro usuário será a rota de contigência, pra evitar que mostre um erro de página não encontrada (error 404).

Basta usar o objeto route seguindo do metodo fallback passando como parametro uma funçao de callback.

em web.php:

Route::fallback(function() {
    echo 'A rota acessada não existe. <a href="'.route('site.index').'"> Clique aqui </a> para ir para a página inicial.';
});

// ao tentar acessar agora uma pagina inexistente, irá mostrar essa mensagem de erro.

///////////////////

Encaminhando parametros da rota para o controlador -
Basicamente, pela rota iremos passar parametros que irão para o controlador.

Em web.php:

Route::get('/teste/{p1}/{p2}', [\App\Http\Controllers\TesteController::class, 'teste'])->name('site.rota1'); // recebendo 2 parametros, que serão obrigatórios (p1 e p2). procurará o método 'teste' dentro do controlador 'TesteController' e executará.

no terminal, digito:
php artisan make:controller TesteController // passando o nome do controlador TesteController.

dentro da classe TesteController, neste controlador, escrevo dentro o metodo 'teste', e coloco os parametros que desejamos receber que colocamos no web.php:

public function teste(int $p1, int $p2) // botei p1 e p2, mas n necessariamente tem q ser os mesmos nomes, oq importa é a ordem. tipei parametros como inteiros. 
{
    echo "A soma de p1 + p2 é: " . ($p1 + $p2);
}

////////////////////////

Encaminhando parâmetros do controlador para visualização - 
Enviando parametros do controlador para uma determinada view. Pra isso, podemos usar array associativo, metodo compact() do PHP que cria um array associativo baseado em parametros ou podemos usar o método With(). 

como estamos usando uma rota de teste e controlador de teste, vamos criar tbm uma view de teste. 

vms criar uma view de teste.

dentro do metodo teste no controlador teste, precisamos agr retornar uma view.

class TesteController extends Controller
{
    public function teste(int $p1, int $p2) 
    {
        return view('site.teste', ['x' => $p1, 'y' => $p2]);
    }
}

como encaminhar esses parametros $p1 e $p2 para a view? usamos array associativo como o 2º parametro da view. no contexto da view, o 'x' vai virar uma variavel. mesma coisa com o 'y'. 

dentro da view teste.blade.php:
P1 = {{ $x }}
<br/>
P2 = {{ $y }}

// foi usado x e y so pra ver q poderia ser qq nome, mas o ideal é usar o msm nome, boa pratica. $p1 e $p2.

------> Outro jeito seria usando o método compact:

Como 2o parametro do metodo view, passamos o metodo compact, e dentro encaminhamos os nomes das variaveis que queremos que sejam submetidas a view, ele recupera os parametros do metodo.

class TesteController extends Controller
{
    public function teste(int $p1, int $p2) 
    {
        return view('site.teste', compact('p1', 'p2')); // criará um array associativo onde o indice sera o nome da variavel, e o valor será o valor contido na respectiva variável.
    }
}

na view, se fizessemos:
P1 = {{ $p1 }}
<br/>
P2 = {{ $p2 }}

// /\ iria funcionar normal. 

---------> Com o método With() agora:

não passemos um 2o parametro, mas em seguida chamemos o metodo 'with' q recebe 2 parametros: o 1o parametro é o nome da variavel no lado da view, e o 2 parametro é seu respectivo valor.

class TesteController extends Controller
{
    public function teste(int $p1, int $p2) 
    {
        return view('site.teste')->with('xyz', $p1)->with('zzz', $p2); 
    }
}

///////////////

Sintaxe Blade -
É o motor de renderizaçao de views do laravel. possui poder de herança de template, q possibilita q views incluem, modificam outras views, etc. 

//////

Blade - incluindo comentários e blocos php puros:

Vms implementar um novo controlador, o 'FornecedorController', para a rota 'fornecedores', e dentro desse controlador vamos criar um método index(), que vai apontar para uma nova view (app.fornecedor.index), e dentro, sim, dessa view, iremos trabalhar com a sintaxe blade.

dentro do web.php, no '.app':
    Route::get('/fornecedor', [\App\Http\Controllers\FornecedorController::class, 'index'])->name('app.fornecedores');

digito no terminal:
php artisan make:controller FornecedorController

dentro do controlador:
class FornecedorController extends Controller
{
    public function index() {
        return view('app.fornecedor.index');
    }
}

// precisamos agr criar a view 'index', q tá dentro da pasta fornecedor q ta dentro da pasta 'app'. ja tinhamos criado 'app', agora criamos pasta 'fornecedor' e nela 'index.blade.php'. digitemos dentro do index <h3>fornecedor</h3>

// Agora, vejamos como criamos comentários usando a sintxe blade, basta usar: {{-- COMENTÁRIO AQUI --}} 

// Incluindo PHP Puro na view:
@php

// aqui, podemos comentar usando a sintaxe nativa do php. /* ... */ tbm

echo 'Texto de teste'; // codificação php pura dentro desse bloco

@endphp

// Entenda que o {{}} é como se fosse a tag curta do php <?= ?>, se fosse {{ 'Texto de Teste' }}

///////////////

If/Else no blade php -

// No caso de PHP nativo, usa-se assim:

@php

if() {
    
} elseif() {

} else {

}

@endphp

// Para o blade php, é um pouco diferente:
class FornecedorController extends Controller
{
    public function index() {
        $fornecedores = ['Fornecedor 1'];
        
        return view('app.fornecedor.index', compact('fornecedores')); // ao usar a variavel 'fornecedores', o laravel ja entende que vai ter q criar uma outra variavel com o mesmo nome 'fornecedores' no lado da view.
    }
}

no arquivo 'index.blade.php':
se usarmos {{$fornecedores}}, não irá funcionar, pq o blade não consegue imprimir um array. portanto, iremos usar um metodo diferente no blade, q é com o @dd :

@dd($fornecedores) // irá mostrar o array.

agora, usemos if else com base nessa variavel. no blade php, usemos sempre @ pra indicar um comando, um comando que precisa ser interpretado pelo blade, pra q esse comando seja interpretado pelo php.
-----> no blade php, não utilizamos ';' para encerrar os comandos.

no blade:
@if(count($fornecedores) > 0 && count(fornecedores < 10)) 
    <H3> Existem alguns fornecedores cadastrados. </h3>
@elseif(count($fornecedores) > 10 )
    <h3> Existem vários fornecedores cadastrados. </h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados. </h3>
@endif

///////////////

Blade - @unless :
Operador de decisao @unless, basicamente é uma inversão do operador if. O if analisa o retorno positivo de uma condiçao, o unless faz o inverso. Unless não tem ligaçao direta com comando php, funciona mais como um atalho. Pode usar ele ou !if.

No FornecedorController:
class FornecedorController extends Controller
{
    public function index() {
        $fornecedores = [
            0 => ['nome' => 'Fornecedor 1', 'status' => 'N']
        ];
        
        return view('app.fornecedor.index', compact('fornecedores'));
    }
}

No index.blade.php:
Fornecedor: {{ $fornecedores[0]['nome']}}
<br>
Status: {{ $fornecedores[0]['status']}}
<br>
@if( !($fornecedores[0]['status'] == 'S') )
    Fornecedor inativo
@endif

// Usando o unless:
Útil para substituir a linha de codigo do if acima, em vez de usar ! , usemos: unless
@unless($fornecedores[0]['status'] == 'S') <!-- executa se o retorno da condição for false -->
    Fornecedor inativo
@endunless

////////////

Usando o @isset

No php nativo:
@php

if(isset($variavel)) {} // retornar true se a variavel estiver definida

@endphp

No FornecedorController.php:
class FornecedorController extends Controller
{
    public function index() {
        $fornecedores = [
            0 => ['nome' => 'Fornecedor 1', 
            'status' => 'N', 
            'cnpj' => '00.000.000/000-00'
        ],
        1 => ['nome' => 'Fornecedor 2', 
            'status' => 'S', 
            'cnpj' => '00.000.000/000-00'
        ],
        ];
        
        return view('app.fornecedor.index', compact('fornecedores'));
    }
}

Ussando @isset, no index.blade.php:
@isset($fornecedores)
    Fornecedor: {{ $fornecedores[1]['nome']}}
    <br/>
    Status: {{ $fornecedores[1]['status']}}
    <br/>
    @isset($fornecedores[1]['cnpj'])
        CNPJ: {{ $fornecedores[1]['cnpj']}}
    @endisset
@endisset

//////////////////

Blade @empty -
Podemos usar o operador @empty como atalho, já que no php 'empty' é um operador usado dentro do if else pra testar se a variavel possui algum valor. retorna true se a variavel estiver vazia. 
--------------> pro php uma variavel é vazia qd a ela é atribuida os valores: '', 0, 0.0, '0', null, false, array(), $var (variavel apenas declarada sem atribuiçao de valor). 
Vejamos fazendo um teste:

No FornecedorController.php:
class FornecedorController extends Controller
{
    public function index() {
        $fornecedores = [
            0 => ['nome' => 'Fornecedor 1', 
            'status' => 'N', 
            'cnpj' => ''
        ],
        1 => ['nome' => 'Fornecedor 2', 
            'status' => 'S', 
            'cnpj' => '00.000.000/000-00'
        ],
        ];
        
        return view('app.fornecedor.index', compact('fornecedores'));
    }
}

No index.blade.php:
@isset($fornecedores)
    Fornecedor: {{ $fornecedores[0]['nome']}}
    <br/>
    Status: {{ $fornecedores[0]['status']}}
    <br/>
    @isset($fornecedores[0]['cnpj'])
        CNPJ: {{ $fornecedores[0]['cnpj']}}
        @empty($fornecedores[0]['cnpj'])
            - Vazio
        @endempty
    @endisset
@endisset

//////////////////////////

Operador Condicional Ternário Extra -
Recurso do PHP, não depende do Laravel. 

No FornecedorController.php:
class FornecedorController extends Controller
{
    public function index() {
        $fornecedores = [
            0 => ['nome' => 'Fornecedor 1', 
            'status' => 'N', 
            'cnpj' => ''
        ],
        1 => ['nome' => 'Fornecedor 2', 
            'status' => 'S', 
            'cnpj' => '00.000.000/000-00'
        ],
        ];

        $msg = isset($fornecedores[1]['cnpj']) ? 'CNPJ informado' : 'CNPJ não informado';
        echo $msg;

        return view('app.fornecedor.index', compact('fornecedores'));
    }
}

Operador ternario é mt usado para atribuiçao de valor a uma variavel, como no caso acima com o $msg.

////////////////

Operador condicional de valor default (??) -
Valor default funciona como um atalho para operadores condicionais ternários.

No index.blade.php:
@isset($fornecedores)
    Fornecedor: {{ $fornecedores[0]['nome']}}
    <br/>
    Status: {{ $fornecedores[0]['status']}}
    <br/>
    CNPJ: {{ $fornecedores[0]['cnpj'] ?? 'Dado não informado'}} // caso a variavel cnpj esteja null ou sem definição irá entrar pra um valor default. nesse caso, 0 não é um valor default.
    <!--
        se $variavel testada não estiver definida (isset)
        ou
        $variavel testada possuir o valor null
    -->
@endisset

e no FornecedorController.php:

class FornecedorController extends Controller
{
    public function index() {
        $fornecedores = [
            0 => ['nome' => 'Fornecedor 1', 
            'status' => 'N', 
            'cnpj' => null
        ],
        1 => ['nome' => 'Fornecedor 2', 
            'status' => 'S', 
            'cnpj' => '1'
        ],
        ];

        $msg = isset($fornecedores[1]['cnpj']) ? 'CNPJ informado' : 'CNPJ não informado';
        echo $msg;

        return view('app.fornecedor.index', compact('fornecedores'));
    }

}

///////////////////////////////

Blade @switch/case:

No FornecedorController criaremos 2 novos índices dentro de cada um dos arrays que representam os fornecedores, ddd e telefone: 

no FornecedorController.php:
public function index() {
        $fornecedores = [
            0 => ['nome' => 'Fornecedor 1', 
            'status' => 'N', 
            'cnpj' => null,
            'ddd' => 21,
            'telefone' => 0000-000
            ],
            1 => ['nome' => 'Fornecedor 2', 
                'status' => 'S', 
                'cnpj' => '1',
                'ddd' => 11,
                'telefone' => 0000-000
            ],
            2 => ['nome' => 'Fornecedor 2', 
                'status' => 'S', 
                'cnpj' => '1',
                'ddd' => 61,
                'telefone' => 0000-000
            ]
        ];

        $msg = isset($fornecedores[1]['cnpj']) ? 'CNPJ informado' : 'CNPJ não informado';
        echo $msg;

        return view('app.fornecedor.index', compact('fornecedores'));
    }

na view index.blade.php em view\app\fornecedor:


@isset($fornecedores)
    Fornecedor: {{ $fornecedores[1]['nome']}}
    <br/>
    Status: {{ $fornecedores[1]['status']}}
    <br/>
    CNPJ: {{ $fornecedores[1]['cnpj'] ?? ''}}  {{-- se for null aplico um texto vazio --}}
    <br/>
    Telefone: {{ $fornecedores[1]['ddd'] ?? ''}} {{ $fornecedores[1]['telefone'] ?? ''}}

    @switch($fornecedores[1]['ddd']) {{-- passando como parametro o que ele quer q escolha --}}
        @case('11')
            São Paulo - SP
        @break

        @case ('21')
            Rio de Janeiro - RJ
        @break

        @case ('61')
            Brasília - DF
        @break

        @default
            Estado não identificado
    @endswitch
@endisset

/////////////////////

Blade - @for =>
Através dele podemos implementar estruturas de repetição em nossos códigos.

@for($i = 0; $i < 10; $i++)

    {{ $i }} <br/> {{-- impressão do $i --}}

@endfor
 
Na prática:
dentro de index.blade.php:


@isset($fornecedores)

    @for($i=0; isset($fornecedores[$i]); $i++)
        Fornecedor: {{ $fornecedores[$i]['nome']}}
        <br/>
        Status: {{ $fornecedores[$i]['status']}}
        <br/>
        CNPJ: {{ $fornecedores[$i]['cnpj'] ?? ''}}  {{-- se for null aplico um texto vazio --}}
        <br/>
        Telefone: {{ $fornecedores[$i]['ddd'] ?? ''}} {{ $fornecedores[$i]['telefone'] ?? ''}}

        <hr/>
    @endfor

@endisset

// vai imprimir cada um dos fornecedores, <hr> é pra ter linha divisória

///////////////

Blade @while -
@isset($fornecedores)

    @php $i = 0; @endphp
    @while(isset($fornecedores[$i]))
        Fornecedor: {{ $fornecedores[$i]['nome']}}
        <br/>
        Status: {{ $fornecedores[$i]['status']}}
        <br/>
        CNPJ: {{ $fornecedores[$i]['cnpj'] ?? ''}}  {{-- se for null aplico um texto vazio --}}
        <br/>
        Telefone: {{ $fornecedores[$i]['ddd'] ?? ''}} {{ $fornecedores[$i]['telefone'] ?? ''}}

        <hr/>
        @php $i ++ @endphp
    @endwhile
@endisset

// como o while nao tem inicio de variavel nem iteraçao, abrimos a tag php e iteramos.

//////////////

Blade @foreach -

Dentro do index.blade.php:
@isset($fornecedores)

    @foreach($fornecedores as $indice => $fornecedor) {{-- cada um dos indices teremos em $indices e iremos atribuir a esses indices os dados de cada um dos fornecedores --}}
        Fornecedor: {{ $fornecedor['nome']}}
        
        <br/>
        Status: {{ $fornecedor['status']}}
        <br/>
        CNPJ: {{ $fornecedor['cnpj'] ?? ''}}  {{-- se for null aplico um texto vazio --}}
        <br/>
        Telefone: {{ $fornecedor['ddd'] ?? ''}} {{ $fornecedor['telefone'] ?? ''}}

        <hr/>
    @endforeach
@endisset

/////////////////

Blade - @forelse

@forelse é uma sintaxe unica do blade, q funciona como combinaçao do foreach com condicional pra verificar se o array está ou não vazio. se houver itens a serem executados no array, o bloco é executado; senão, o fluxo é desviado. Sintaxe é a msm do foreach, mas temos o @empty para desviar o fluxo.

@isset($fornecedores)
    @forelse($fornecedores as $indice => $fornecedor) {{-- cada um dos indices teremos em $indices e iremos atribuir a esses indices os dados de cada um dos fornecedores --}}
        Fornecedor: {{ $fornecedor['nome']}}
        
        <br/>
        Status: {{ $fornecedor['status']}}
        <br/>
        CNPJ: {{ $fornecedor['cnpj'] ?? ''}}  {{-- se for null aplico um texto vazio --}}
        <br/>
        Telefone: {{ $fornecedor['ddd'] ?? ''}} {{ $fornecedor['telefone'] ?? ''}}

        <hr/>
    @empty
        Não existem fornecedores cadastrados.
    @endforelse
@endisset

//////////////////////

Escapando a tag de impressão do Blade -
Para dizer que certo trecho de bloco não seja executado, não seja interpretado coloque @ antes de {{}}


@isset($fornecedores)

    @forelse($fornecedores as $indice => $fornecedor) {{-- cada um dos indices teremos em $indices e iremos atribuir a esses indices os dados de cada um dos fornecedores --}}
        Fornecedor: @{{ $fornecedor['nome']}}
        <br/>
        Status: @{{ $fornecedor['status']}}
        <br/>
        CNPJ: @{{ $fornecedor['cnpj'] ?? ''}}  {{-- se for null aplico um texto vazio --}}
        <br/>
        Telefone: @{{ $fornecedor['ddd'] ?? ''}} @{{ $fornecedor['telefone'] ?? ''}}

        <hr/>
    @empty
        Não existem fornecedores cadastrados.
    @endforelse
@endisset

/////////////////

Blade - Variável Loop -
Temos o objeto $loop, 

@isset($fornecedores)

    @forelse($fornecedores as $indice => $fornecedor) {{-- cada um dos indices teremos em $indices e iremos atribuir a esses indices os dados de cada um dos fornecedores --}}
        Iteração atual: {{ $loop->iteration }}
        <br/>
        Fornecedor: {{ $fornecedor['nome']}}
        <br/>
        Status: {{ $fornecedor['status']}}
        <br/>
        CNPJ: {{ $fornecedor['cnpj'] ?? ''}}  {{-- se for null aplico um texto vazio --}}
        <br/>
        Telefone: {{ $fornecedor['ddd'] ?? ''}} {{ $fornecedor['telefone'] ?? ''}}

        <hr/>
    @empty
        Não existem fornecedores cadastrados.
    @endforelse
@endisset

Temos tbm o $iteration->first, que diz se a iteração que a gente está é a primeira. Temos o last e o $loop->count

@isset($fornecedores)

    @forelse($fornecedores as $indice => $fornecedor) {{-- cada um dos indices teremos em $indices e iremos atribuir a esses indices os dados de cada um dos fornecedores --}}
        Iteração atual: {{ $loop->iteration }}
        <br/>
        Fornecedor: {{ $fornecedor['nome']}}
        <br/>
        Status: {{ $fornecedor['status']}}
        <br/>
        CNPJ: {{ $fornecedor['cnpj'] ?? ''}}  {{-- se for null aplico um texto vazio --}}
        <br/>
        Telefone: {{ $fornecedor['ddd'] ?? ''}} {{ $fornecedor['telefone'] ?? ''}}
        <br/>
        @if($loop->first)
            Primeira iteração do Loop
        @endif
        
        @if($loop->last)
            Primeira iteração do Loop
            <br/>
            Total de registros: {{ $loop->count }}
        @endif
        
        <hr/>
    @empty
        Não existem fornecedores cadastrados.
    @endforelse
@endisset

E se quiser mostrar mais detalhado, atributos do objeto, etc use @dd($loop) logo depois do forelse.

/////////////////

Super Gestão - Melhorando o Visual -
Baixamos novo arquivo 'views.zip' na aula e substituimos.

digitemos no terminal -> php artisan view:clear

php artisan serve 

vamos usar as views que ele colocou. 

////////////////////

Assets -
Qd trabalhamos com front-end em aplicaçao web, ouve-se muito assets. Ele representa tudo aquilo que é utilizado para complementar o conteudo do front-end das aplicaçoes web (midias, imagens, estilos css, javascript, etc)

/////////////////

Adicionando Assets às views -
baixemos arquivo chamado img.zip, e, dentro da pasta 'public' no projeto, coloquemos o diretório img. Todas as mídias que complementam nossas páginas HTML, devem ser colocadas no diretório 'public' da aplicaçao para que elas possam ser requisitadas através da internet; arquivos JS, CSS, imagem, video, som, etc, todos esses assets q acompanham o HTML precisam estar publicas. 

No principal.blade.php, vemos:
<div class="logo">
    <img src="img/logo.png">
</div>

o diretorio 'img' tem q estar dentro do diretorio 'public'. esse é o modo relativo.
o modo mais apropriado de incluir assets em nossas views é através da utilização de um helper do laravel chamado asset(''), onde dentro coloco uma string com referencia. com o asset podemos configurar a raiz dos nossos assets, entao com isso tenho mais flexibilidade em ter mudança de onde localizar nossos arquivos.

<div class="logo">
    <img src="{{ asset('img/logo.png')}}">
</div>

agora basta fazer o mesmo para todos os img src.

//////////////////////

Adicionando arquivos CSS externos as páginas web - 

Vamos separar os <style> em arquivos css externos para minimizar o tamanho de nossas views.
Dentro do diretorio 'public', criemos um diretorio 'css', colocaremos num arquivo q esteja dentro de css.
dentro da pasta 'css', colocamos um arquivo chamado 'estilo_basico.css' e colocamos o codigo style css, q tem nas views, dentro dele. 

Inclusão do css feito pela tag <link rel="stylesheet" href="{{asset('css/estilo_basico.css')}}">

//////////////////////

Blade - Template com @extends, @section e @yield parte 1

Podemos começar nosso template centralizando as informações comuns entre as views. Permitindo que cada view faça sua especialização. 
Dentro de 'views', no diretorio 'site', criaremos um novo diretorio chamado 'layouts', e dentro dele criar arquivo chamado 'basico.blade.php'.

Como conectar nossa view com o template?
Recortamos a parte inicial ate o 'body' de sobre-nos e colamos em 'basico.blade.php', e fechamos body e html no basico.blade.php.

- Essa comunicação entre template e view é feita através da extensão @extends(), precisamos usá-lo na view que vai receber um template, que vai ser trabalhada com base em um template, pois qd acessarmos uma rota, a rota vai direcionar a requisiçao pra view que queremos acessar, portanto a view tem q indicar qual template ela quer extender.

Em sobre-nos.php, damos @extends('site.layouts'). O 'extends' vai direto para o diretorio 'views' contido dentro de 'resources', precisamos então passar o caminho do nosso template através do diretório 'views':

@extends('site.layouts.basico')

// /\ agora, estamos conectando nosso template com nossa view. Próximo passo agora é pegar todo conteudo da nossa view e direcioná-lo para áreas especificas do nosso layout. Selecionamos na view o codigo html que queremos enviar como parametro para nosso layout. Iniciamos com section, damos um nome ela, e encerramos com endsection, q todo codigo q tiver nela será direcionado para o template. 

--------> https://prnt.sc/e8AoH-DAfVQR

Meu objetivo é pegar todo conteudo q tem dentro do body em sobre-nos, e colocar dentro do template em basico.blade.php

Dentro de sobre-nos, depois de começar o body coloco @section('conteudo') e no final antes de fechar o body coloco @endsection. essa seçaõ 'conteudo' representa todo o codigo html encapsulado na seção. como o nome da seção q escolhemos é 'conteudo', vamos no template, em basico.blade.php, dentro do body escrevamos: @yield('conteudo').

Façamos o mesmo paras outras views, com extends e section, em contato e em principal

/////////////////

Blade - Template com @extends, @section e @yield parte 2 -

Ao navegar por cada pagina, verá que o title estará 'sobre nós' em cada página, para mudar isto, em 'basico.blade.php' mude o title para @yield('titulo'), q significa que o template estará apto para receber uma section com esse nome e aplicar nesse local um nome.
dentro de contato.blade.php criemos uma @section, mas com um 2o parametro, onde o 2o parametro será o valor dele.

contato.blade.php:
@section('titulo', 'Contato')

façamos em cada uma das views isso.

Posso fazer passando por controller tbm:
Agora troco por variável:
@section('titulo', $titulo)

e na renderizaçao das views dos controllers, passamos array associativo.

em ContatoController.php:
public function contato() {
        return view('site.contato', ['titulo' => 'Contato (teste)']);
    }
    
/////////////////////////

Realizando include de views dentro de outras views -
É como deslocar toda codificação de um lugar para o exato ponto de um include.

Dentro do diretorio 'layouts' criemos um outro diretorio chamado '_partials'. Dentro dele, criemos um arquivo chamado 'topo.blade.php', e dentro dele vou colocar o conteudo que representa o topo da nossa aplicação, que encapsula o menu e a imagem. Dentro do arquivo 'principal.blade.php', vamos recortar a div 'topo' e colar nesse arquivo topo.blade.php que criamos. 

Agora, no principal.blade.php, fazer o respectivo include:
@include('site.layouts._partials.topo') {{-- ele já verifica automaticamente o diretorio views --}}

A gente pode fazer o mesmo agora para outras views, sobre-nos e contato. Mas, em vez de fazer isso, basta colocar em 'basico.blade.php', q ali passamos a include na yield 'conteudo', e já é replicada para toda aplicação.

////////////

Super Gestão - Enviando formulário de contato -
Vamos começar abrindo o formulario 'web.php' dentro de 'routes'.
1o passo é definir os parametros de action (pra onde o formulario será enviado, qual rota) e o metodo (qual verbo http a ser utilizado);

O objetivo vai ser enviar um formulario em contato e receber parametros através do 'get' na URL; 

Dentro de contato.blade.php:
<form action={{route('site.contato')}} method="get"> // posso omitir o method get, ja que por padrão é enviado 'get'

coloco os 'names' e 'values' nos campos, select e options pra dar variavel aos campos. agora, significa na vdd que vai enviar o formulario vai ser enviado para site.contato, ou seja, q está definido em web.php, e por sua vez, vai acessar o metodo 'contato' dentro de 'ContatoController'.;

////////////////////

Enviando formulario de contato via POST -
Agora vamos trabalhar com o método POST..

1o passo é modificar o metodo de envio do formulario para 'POST'.
Temos que criar uma rota que faça envio via POST.

Em web.php adiciono:
Route::post('/contato', [\App\Http\Controllers\ContatoController::class, 'contato'])->name('site.contato');
// não preciso apagar a mesma routa com get (route::get)

Mas ainda sim nao funciona, pq o laravel exige que todos formularios submetidos via POST tenham um Token, uma identificaçao que garanta que aquele formulario esteja sendo enviado via post pelo client daquela requisição. 
Para isso, basta lá na view, em 'contato.blade.php,', dentro do 'form', incluir a tag: @csrf

///////////////////

Entendendo o token @csrf - 
Significa: Falsificação de solicitação entre sites
A vulnerabilidade de cross-site poderá ser minimizada com o @csrf, já que um token será disponibilizado à página legítima.

//////////////

Blade - Componentes (@component) -
@component é um recurso para incluir views dentro de outras views. Parecido com include, mas são diferentes, no component é mais avançado, permitindo incluir mais trechos de codigos recorrentes.

Podemos usar o formulário de contato como recorrente para reutilizar.

Vamos criar um novo diretorio dentro de _layouts chamado de _componentes, e dentro dele criemos um novo arquivo chamado form_contato.blade.php, q é uma view normal. A ideia é trazer para esta view o formulario. Vamos no contato.blade.php e trazer o formulario 'form' para o form_contato.blade.php. Lembrando que um componente é uma view normal, a diferença é a forma como essa view é incluida dentro de outra view. 

Em 'contato.blade.php', agora usamos a instrução @component e passamos como parametro a view a ser incluida nesse ponto a ser um componente, no mesmo lugar onde ficava o 'form':
<div class="contato-principal">
    @component('site.layouts._components.form_contato')
    @endcomponent
</div>

- Façamos o mesmo para 'principal.blade.php', tiremos o form de lá. 

///////////////////

Enviando parametros para componentes -
Podemos passar codificaçao html nos componentes. 
Exemplo:

Em contato.blade.php:
<div class="contato-principal">
    @component('site.layouts._components.form_contato')
        <p>Testando</p>
    @endcomponent
</div>

Em form_contato.blade.php:
{{ $slot }} // antes do codigo começar.

{{ $slot }} é para dizer para imprimir o que coloquei dentro de @component.

- Podemos passar um array associativo imprimindo 'x'.
Em contato.blade.php:
@component('site.layouts._components.form_contato', [x => 35])
    <p>Testando</p>
@endcomponent

Em form_contato.blade.php:
antes do codigo coloco: {{ $x }}

/////////////////////

Models, Migrations, Seeders, Factories, Banco de dados, Tinker e Eloquent ORM -

Com Models, trazemos os beneficios da POO, dentre eles a reutilizaão de código. Um model é uma classe que vai representar um tipo de dado/um objeto no sistema. Dentro do terminal digitemos:
php artisan make:model SiteContato 

// criamos um model que vai representar cada um dos contatos feitos através do site (Super Gestão). Criaremos uma classe q será instanciada contendo os respectivos atributos de um contato, para que mais adiante este objeto possa ser persistido em nosso banco de dados. Passando a flag -m na criaçao de um modelo:

php artisan make:model SiteContato -m // com isto, iremos automaticamente criar um modelo e também uma migration. 

=======> Passar a flag -m se o objetivo for armazenar os dados desse objeto no banco de dados. Portanto, geralmente vai usar -m para criar uma migration. Geralmente vai querer salvar no banco de dados as informaçoes desse modelo/objeto. 

Para cada modelo, é interessante criar uma migration, portanto, passar a flag -m para criar a migration, pq geralmente vc vai querer salvar no banco de dados as informaçoes do seu model/objeto, senão, vc não precisa passar a flag -m, pq os dados não seriam armazenados no banco. 

Para acessarmos nosso modelo, vamos na raiz do diretorio 'app' e acessamos 'models': acharemos o 'SiteContato.php'. Veremos ali a classe SiteContato extendendo a classe Model. 